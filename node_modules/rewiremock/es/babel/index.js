function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var templateOptions = {
  placeholderPattern: /^([A-Z0-9]+)([A-Z0-9_]+)$/
};

var REWIREMOCK_GLOBAL = { name: 'rewiremock' };

var isRewiremock = function isRewiremock(expr) {
  var callee = expr.get('callee');
  if (!callee.node) {
    return false;
  }
  var object = callee.get('object');
  return callee.isIdentifier(REWIREMOCK_GLOBAL) || callee.isMemberExpression() && isRewiremock(object);
};

module.exports = function (args) {
  var template = args.template;


  var enable = template('rewiremock.enable();\n', templateOptions);
  var disable = template('rewiremock.disable();\n', templateOptions);

  var registrations = template('(function(){\n  global["REWIREMOCK_HOISTED"] = global["REWIREMOCK_HOISTED"] || [];\n  global["REWIREMOCK_HOISTED"].push(function(rewiremock){     \n    MOCKS \n   });\n})();', templateOptions);

  var REGISTRATIONS = Symbol('registrations');

  return {
    visitor: {
      Program: {
        enter: function enter(_ref) {
          var node = _ref.node;

          node[REGISTRATIONS] = {
            imports: [],
            mocks: []
          };
        },
        exit: function exit(_ref2) {
          var node = _ref2.node;
          var _node$REGISTRATIONS = node[REGISTRATIONS],
              imports = _node$REGISTRATIONS.imports,
              mocks = _node$REGISTRATIONS.mocks;

          if (mocks.length) {

            var rewiremock = imports.find(function (_ref3) {
              var node = _ref3.node;
              return node.source.value.indexOf('rewiremock') >= 0;
            });
            if (!rewiremock) {
              /* eslint-disable no-console */
              console.warn('rewiremock not found in imports');
            }

            var mocker = registrations({
              MOCKS: [enable()].concat(_toConsumableArray(mocks))
            });

            node.body.push(mocker);

            mocker._blockHoist = Infinity;

            imports[imports.length - 1].insertAfter(disable());
          }
        }
      },

      ImportDeclaration: function ImportDeclaration(path) {
        path.parent[REGISTRATIONS].imports.push(path);
      },
      ExpressionStatement: function ExpressionStatement(path) {
        if (!path.parent[REGISTRATIONS]) {
          return false;
        }

        var expr = path.get('expression');

        if (!expr.isCallExpression()) {
          return false;
        }

        if (isRewiremock(expr)) {
          path.parent[REGISTRATIONS].mocks.push(path.node);
          path.remove();
        }
      }
    }
  };
};