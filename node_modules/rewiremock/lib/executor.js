'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requireModule = undefined;

var _path = require('path');

var _module = require('./module');

var _module2 = _interopRequireDefault(_module);

var _plugins = require('./plugins');

var _mocks = require('./mocks');

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

var _asyncModules = require('./asyncModules');

var _asyncModules2 = _interopRequireDefault(_asyncModules);

var _getModule = require('./getModule');

var _getModule2 = _interopRequireDefault(_getModule);

var _compareModuleExports = require('compare-module-exports');

var _compareModuleExports2 = _interopRequireDefault(_compareModuleExports);

var _common = require('./plugins/_common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const matchOrigin = (0, _compareModuleExports2.default)('rewiremock');
const thisModule = module;

const patternMatch = fileName => pattern => {
  if (typeof pattern == 'function') {
    return pattern(fileName);
  }
  return fileName.match(pattern);
};

const requireModule = exports.requireModule = (name, parentModule) => {
  if (typeof __webpack_require__ !== 'undefined') {
    return __webpack_require__(name);
  } else {
    //return Module._load(name);
    return parentModule ? _getModule2.default._load(name, parentModule) : require(name);
  }
};

const testPassby = (request, module) => {
  const {
    parentModule,
    mockedModules
  } = (0, _globals2.default)();

  const passBy = (0, _globals.collectScopeVariable)('passBy');
  const isolation = (0, _globals.getScopeVariable)('isolation');

  // was called from test
  if ((0, _module.moduleCompare)(module, parentModule)) {
    //if (module === parentModule || module == module.parent) {
    return true;
  }
  // if parent is in the pass list - pass everything
  let fileName = _module2.default._resolveFilename(request, module);
  let m = module;

  const test = fileName => !isolation.noAutoPassBy && mockedModules[fileName] || // parent was mocked
  passBy.filter(patternMatch(fileName)).length // parent is in pass list
  ;

  while (m) {
    if (test(fileName)) {
      return true;
    }
    fileName = (0, _module.getModuleName)(m);
    m = (0, _module.getModuleParent)(m);
  }
  return test(fileName);
};

function mockResult(name, mock, dataFactory) {
  const factory = () => {
    const data = dataFactory();
    if (mock.matchOrigin) {
      const matchResult = matchOrigin(mock.original, data, name, '%mock%', { noFunctionCompare: true });
      if (matchResult) {
        // eslint-disable-next-line no-console
        matchResult.forEach(line => console.error(line));
        throw new Error('Rewiremock: provided mocks does not match ' + name);
      }
    }
    if (data && !data.default) {
      if (['object', 'function'].indexOf(typeof data) >= 0) {
        Object.defineProperty(data, 'default', {
          enumerable: false,
          value: data
        });
      }
    }
    return data;
  };

  if (mock.flag_dynamic) {
    const origin = factory();
    if (['object', 'function'].indexOf(typeof origin) >= 0) {
      return new Proxy(origin, {
        get(target, prop) {
          return factory()[prop];
        }
      });
    }
  }
  return factory();
}

function standardStubFactory(name, object, deeperMock) {
  if (typeof object === 'function') {
    return () => {};
  }
  if (typeof object === 'object') {
    return deeperMock(deeperMock);
  }
  return object;
}

function mockThought(stubFactory, mockOriginal, name = '') {
  if (typeof mockOriginal === 'function') {
    return stubFactory(name || 'default', mockOriginal);
  }
  if (typeof mockOriginal === 'object') {
    const deeperMock = (key, value) => mockThought(stubFactory, value, name ? `${name}.${key}` : key);
    if (Array.isArray(mockOriginal)) {
      return mockOriginal.map((x, i) => deeperMock(i, x));
    } else {
      return Object.keys(mockOriginal).map(key => ({ key, value: deeperMock(key, mockOriginal[key]) })).reduce((acc, x) => Object.assign(acc, { [x.key]: x.value }), {});
    }
  }
  return mockOriginal;
}

function monkeyPatchPath(addr) {
  const path = addr.split('/');
  if (path[0] === '..') {
    path[0] = '.';
    return path.join('/');
  }
  return addr;
}

function asyncTest() {
  const asyncModulesLeft = _asyncModules2.default.hasAsyncModules();
  if (asyncModulesLeft) {
    /* eslint-disable no-console */
    console.error('Rewiremock: listed async modules should finish loading first. Use async API of rewiremock.', asyncModulesLeft.map(module => module.creator.toString()));
    /* eslint-enable */
    throw new Error('Rewiremock: listed async modules should finish loading first. Use async API of rewiremock.');
  }
}

function mockLoader(request, parent, isMain) {
  const {
    parentModule,
    mockedModules,
    isolation
  } = (0, _globals2.default)();

  asyncTest();

  const baseRequest = _module2.default._resolveFilename(request, parent);
  const shortRequest = monkeyPatchPath((0, _path.relative)((0, _module.getModuleName)(parent), request));

  if ((0, _module.moduleCompare)(parent, parentModule) || (0, _module.moduleCompare)(parent, thisModule)) {
    delete _module2.default._cache[baseRequest];
    mockedModules[baseRequest] = true;
  }

  const mock = (0, _mocks.getMock)(baseRequest) || (0, _mocks.getMock)(request) || (0, _mocks.getMock)(shortRequest) || (0, _plugins.autoMock)(baseRequest);

  if (mock) {
    mock.wasRequired = true;
    const shouldResult = {};
    if ((0, _plugins.shouldMock)(mock, request, parent, parentModule, shouldResult)) {
      // this file fill be not cached, but it`s opener - will. And we have to remember it
      mockedModules[(0, _module.getModuleName)(parent)] = true;
      mock.usedAs = mock.usedAs || [];
      mock.usedAs.push(baseRequest);

      mockedModules[baseRequest] = true;

      if (mock.allowCallThrough || mock.matchOrigin || mock.mockThrough) {
        if (!mock.original) {
          mock.original = (0, _module.originalLoader)(request, parent, isMain);
        }
      }

      if (mock.mockThrough) {
        const factory = mock.mockThrough === true ? (0, _globals.getScopeOption)('stubFactory') : mock.mockThrough;
        mock.override = mockThought(factory || standardStubFactory, mock.original);
        return mockResult(request, mock, () => Object.assign({}, mock.override, mock.value, { __esModule: mock.original.__esModule }));
      }

      if (mock.overrideBy) {
        if (!mock.override) {
          if (typeof mock.overrideBy === 'string') {
            mock.override = (0, _module.originalLoader)((0, _module.pickModuleName)(mock.overrideBy, parent), parent, isMain);
          } else {
            mock.override = mock.overrideBy({
              name: request,
              fullName: baseRequest,
              parent: parent,
              original: mock.original,
              requireActual: name => (0, _module.originalLoader)((0, _module.pickModuleName)(name, parent), parent, isMain)
            });
          }
        }
        return mockResult(request, mock, () => mock.override);
      }

      if (mock.allowCallThrough) {
        if (typeof mock.original === 'function') {
          if (typeof mock.value === 'object' && Object.keys(mock.value).length === 0) {
            return mockResult(request, mock, () => mock.original);
          } else {
            throw new Error('rewiremock: trying to merge Functional base with callThrough mock at ' + request + '. Use overrideBy instead.');
          }
        }
        return mockResult(request, mock, () => Object.assign({}, mock.original, mock.value, { __esModule: mock.original.__esModule }));
      }

      return mockResult(request, mock, () => mock.value);
    } else {
      mock.rejected = mock.rejected || [];
      if (shouldResult.plugins) {
        mock.rejected.push({
          parent,
          plugins: shouldResult.plugins.filter((p, index) => shouldResult.values[index] === _common.NO).map(p => p.name)
        });
      }
      // why you shouldn't?
    }
  }

  if (isolation && !mockedModules[baseRequest]) {
    if (!testPassby(request, parent)) {
      throw new Error('rewiremock: isolation breach by [' + request + ']. Requested from ', (0, _module.getModuleName)(parent));
    }
  }

  return (0, _module.originalLoader)(request, parent, isMain);
}

exports.default = mockLoader;