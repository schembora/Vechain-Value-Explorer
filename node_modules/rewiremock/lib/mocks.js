'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetMock = exports.getAllMocks = exports.getAllAsyncMocks = exports.getAsyncMock = exports.getMock = exports.insertMock = exports.getAsyncModuleName = undefined;

var _path = require('path');

var _pathParse = require('path-parse');

var _pathParse2 = _interopRequireDefault(_pathParse);

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

var _common = require('./_common');

var _module = require('./module');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const genMock = name => {
  return {
    name,
    value: {}
  };
};

const insertMock = (name, mock) => (0, _globals2.default)().mocks[name] = mock;
const resetMock = name => insertMock(name, genMock(name));

const pickFrom = (mocks, name) => {
  const ext = _common.extensions.find(ext => mocks.hasOwnProperty(name + ext));
  if (ext !== undefined) {
    return mocks[name + ext];
  }
};

const getMock = (name, scope = (0, _globals2.default)()) => {
  const { mocks } = scope;
  const fn = (0, _pathParse2.default)(name);
  const shortName = (0, _path.join)(fn.dir, fn.name);
  const wshortName = fn.dir + '/' + fn.name;
  const indexName = fn.name === 'index' ? fn.dir : null;

  const mock = pickFrom(mocks, name) || indexName && pickFrom(mocks, indexName) || pickFrom(mocks, shortName) || pickFrom(mocks, wshortName);

  if (!mock && scope.parentScope) {
    return getMock(name, scope.parentScope);
  }
  return mock;
};

const getAsyncModuleName = exports.getAsyncModuleName = (creator, parent) => {
  return creator.toString() + ':' + (0, _module.getModuleName)(parent);
};

const getAsyncMock = (creator, parent, scope = (0, _globals2.default)()) => {
  const signature = getAsyncModuleName(creator, parent);
  const mock = resetMock(signature);
  scope.asyncMocks.push({
    mock,
    creator,
    loaded: false
  });
  return mock;
};

const collectMocks = (result, selector) => {
  const collect = scope => {
    if (scope.parentScope) {
      collect(scope.parentScope);
    }
    const mocks = selector(scope);
    Object.keys(mocks).forEach(key => result[key] = mocks[key]);
  };
  collect((0, _globals2.default)());
  return result;
};

const getAllMocks = () => {
  return collectMocks({}, scope => scope.mocks);
};

const getAllAsyncMocks = () => {
  return collectMocks([], scope => scope.asyncMocks.filter(mock => !mock.loaded)).filter(mock => !!mock);
};

exports.insertMock = insertMock;
exports.getMock = getMock;
exports.getAsyncMock = getAsyncMock;
exports.getAllAsyncMocks = getAllAsyncMocks;
exports.getAllMocks = getAllMocks;
exports.resetMock = resetMock;