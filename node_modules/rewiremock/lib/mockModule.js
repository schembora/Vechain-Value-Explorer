'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanup = exports.removePlugin = exports.addPlugin = exports.mockModule = undefined;

var _module = require('./module');

var _module2 = _interopRequireDefault(_module);

var _wipeCache = require('./wipeCache');

var _wipeCache2 = _interopRequireDefault(_wipeCache);

var _scope = require('./scope');

var _scope2 = _interopRequireDefault(_scope);

var _globals = require('./globals');

var _plugins = require('./plugins');

var _mocks = require('./mocks');

var _mock = require('./mock');

var _mock2 = _interopRequireDefault(_mock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let parentModule = (0, _module.getModuleParent)(module);
let mockScope = null;
const scope = () => (0, _globals.setScope)(mockScope);
const updateScope = (parentScope = null) => {
  mockScope = (0, _scope2.default)(parentScope, parentModule);
  scope();
};

updateScope();

/** main **/

/**
 * @name rewiremock
 * @param {String|Function} module name
 * @return {ModuleMock}
 */
function mockModule(moduleName) {
  scope();
  if (typeof moduleName === 'function') {
    return (0, _plugins.onMockCreate)(new _mock2.default((0, _mocks.getAsyncMock)(moduleName, parentModule)));
  } else {
    const name = (0, _plugins.convertName)(moduleName, parentModule);
    (0, _mocks.resetMock)(name);
    return (0, _plugins.onMockCreate)(new _mock2.default((0, _mocks.getMock)(name)));
  }
}

mockModule.getMock = module => {
  let moduleName = module;
  if (typeof moduleName === 'function') {
    moduleName = (0, _mocks.getAsyncModuleName)(moduleName, parentModule);
  } else {
    moduleName = (0, _plugins.convertName)(moduleName, parentModule);
  }
  const mock = (0, _mocks.getMock)(moduleName);
  if (mock) {
    return new _mock2.default(mock);
  }
  return null;
};

/**
 * @name rewiremock.resolve
 * @param {String} module name
 * @return {String} converted module name
 */
mockModule.resolve = module => {
  scope();
  return (0, _plugins.convertName)(module, parentModule);
};

/** flags **/

/**
 * Activates module isolation
 * @param {Object} [options]
 * @param {Boolean} [options.noAutoPassBy] includes mocked modules to a isolation scope. Usage with mock.callThrough.
 */
mockModule.isolation = (options = {}) => {
  mockScope.isolation = Object.assign({}, options);
  return mockModule;
};

/**
 * Deactivates isolation
 */
mockModule.withoutIsolation = () => {
  mockScope.isolation = false;
  return mockModule;
};

mockModule.forceCacheClear = mode => {
  mockScope.forceCacheClear = mode ? mode : true;
};

/**
 * Adding new passby record
 * @param {String|RegEx|Function} pattern
 */
mockModule.passBy = pattern => {
  mockScope.passBy.push(pattern);
  return mockModule;
};

mockModule.overrideEntryPoint = parent => {
  mockScope.parentModule = parentModule = parent || (0, _module.getModuleParent)((0, _module.getModuleParent)(module));
};

/** interface **/

/**
 * enabled rewiremock
 */
mockModule.enable = () => {
  scope();
  _module2.default.overloadRequire();
  storeCache();
  (0, _wipeCache2.default)();
  (0, _plugins.onEnable)((0, _mocks.getAllMocks)());
  return mockModule;
};

/**
 * disabled rewiremock
 */
mockModule.disable = () => {
  scope();
  _module2.default.restoreRequire();
  (0, _plugins.onDisable)((0, _mocks.getAllMocks)());
  mockModule.withoutIsolation();
  mockModule.flush();
  return mockModule;
};

/**
 * Requires file with hooks
 * @param {String|Function} file
 * @param {Object|Function} overrides
 */
mockModule.proxy = (file, overrides = {}) => {
  let result = 0;
  const stubs = typeof overrides === 'function' ? overrides(_mock2.default.inlineConstructor) : overrides;

  mockModule.inScope(() => {
    Object.keys(stubs).forEach(key => mockModule(key).from(stubs[key]));

    mockModule.enable();
    if (typeof file === 'string') {
      result = mockModule.requireActual(file);
    } else {
      result = file();
    }
    mockModule.disable();
  });
  return result;
};

/**
 * Imports file with hooks
 * @param {Function} importFunction (use import)
 * @param {Object|Function} overrides
 * @return {Promise}
 */
mockModule.module = (importFunction, overrides = {}) => {
  const stubs = typeof overrides === 'function' ? overrides(_mock2.default.inlineConstructor) : overrides;

  return mockModule.around(importFunction, () => Object.keys(stubs).forEach(key => mockModule(key).from(stubs[key])));
};

/**
 * Creates temporary executing scope. All mocks and plugins you will add in callback will be removed at exit.
 * @param callback
 */
mockModule.inScope = callback => {
  const currentScope = mockScope;
  let error;
  updateScope(currentScope);
  try {
    callback();
  } catch (e) {
    error = e;
  }

  mockScope = currentScope;
  if (error) throw error;
  return mockModule;
};

/**
 * executes module in sandbox
 * @param {Function} loader loader callback
 * @param {Function} [createCallback] - optional callback to be executed before load.
 * @return {Promise}
 */
mockModule.around = (loader, createCallback) => {
  return new Promise((resolve, reject) => {
    const currentScope = mockScope;
    updateScope(currentScope);

    const restore = () => {
      mockModule.disable();
      mockScope = currentScope;
    };

    Promise.resolve(createCallback && createCallback(mockModule)).then(() => _module2.default.probeAsyncModules()).then(() => mockModule.enable()).then(() => Promise.resolve(loader()).then(mockedResult => {
      restore();
      resolve(mockedResult);
    }, err => {
      restore();
      reject(err);
    }));
  });
};

mockModule.stubFactory = factory => {
  const currentScope = mockScope;
  currentScope.options.stubFactory = factory;
};

const storeCache = () => {
  mockScope.requireCache = mockScope.requireCache || Object.assign({}, require.cache);
};

const restoreCache = () => {
  const oldCache = mockScope.requireCache;
  const newCache = require.cache;
  if (oldCache) {
    Object.keys(oldCache).filter(key => !newCache[key]).forEach(key => newCache[key] = oldCache[key]);

    mockScope.requireCache = null;
  }
};

const swapCache = () => {
  const oldCache = mockScope.requireCache;
  const newCache = require.cache;
  if (oldCache) {
    Object.keys(newCache).filter(key => !oldCache[key]).filter(key => key.indexOf('.node') < 0).forEach(key => delete newCache[key]);

    Object.keys(oldCache).forEach(key => newCache[key] = oldCache[key]);

    mockScope.requireCache = null;
  }
};
/**
 * flushes all active overrides
 */
mockModule.flush = () => {
  const forceCacheClear = (0, _globals.getScopeVariable)('forceCacheClear');
  // flush away soiled modules
  (0, _wipeCache2.default)(mockScope.mockedModules);
  mockScope.mockedModules = {};
  if (forceCacheClear) {
    if (forceCacheClear !== 'nocache') {
      // restore cache completely
      swapCache();
    }
  } else {
    // merge caches
    restoreCache();
  }
};

/**
 * Low-level require
 * @param {String} fileName
 */
mockModule.requireActual = fileName => _module2.default.require(_module2.default.relativeFileName(fileName, parentModule), parentModule);

/**
 * Low-level import
 * @param {String} fileName
 */
mockModule.importActual = fileName => Promise.resolve(undefined.requireActual(fileName));

/**
 * flushes anything
 */
mockModule.clear = () => {
  updateScope();
  scope();
  mockModule.withoutIsolation();
  mockModule.flush();
};

const cleanup = () => {
  delete require.cache[require.resolve(__filename)];
};

const addPlugin = plugin => {
  scope();
  (0, _plugins.addPlugin)(plugin);
};

const removePlugin = plugin => {
  scope();
  (0, _plugins.removePlugin)(plugin);
};

mockModule.addPlugin = plugin => {
  addPlugin(plugin);
  return mockModule;
};

exports.mockModule = mockModule;
exports.addPlugin = addPlugin;
exports.removePlugin = removePlugin;
exports.cleanup = cleanup;