"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const crypto_1 = require("crypto");
const keccak = require('keccak');
const secp256k1 = require('secp256k1');
const blake = require('blakejs');
/**
 * computes blake2b 256bit hash of given data
 * @param data one or more Buffer | string
 */
function blake2b256(...data) {
    let ctx = blake.blake2bInit(32, null);
    data.forEach(d => {
        if (Buffer.isBuffer(d))
            blake.blake2bUpdate(ctx, d);
        else
            blake.blake2bUpdate(ctx, Buffer.from(d, 'utf8'));
    });
    return new types_1.Bytes32(Buffer.from(blake.blake2bFinal(ctx)));
}
exports.blake2b256 = blake2b256;
/**
 * computes keccak256 hash of given data
 * @param data one or more Buffer | string
 */
function keccak256(...data) {
    let h = keccak('keccak256');
    data.forEach(d => {
        if (Buffer.isBuffer(d))
            h.update(d);
        else
            h.update(Buffer.from(d, 'utf8'));
    });
    return new types_1.Bytes32(h.digest());
}
exports.keccak256 = keccak256;
/** Secp256k1 methods set */
var Secp256k1;
(function (Secp256k1) {
    /** generate private key  */
    function generatePrivateKey() {
        for (;;) {
            let privKey = crypto_1.randomBytes(32);
            if (secp256k1.privateKeyVerify(privKey)) {
                return new types_1.Bytes32(privKey);
            }
        }
    }
    Secp256k1.generatePrivateKey = generatePrivateKey;
    /**
     * derive public key(uncompressed) from private key
     * @param privKey the private key
     */
    function derivePublicKey(privKey) {
        return secp256k1.publicKeyCreate(privKey.bytes, false /* uncompressed */);
    }
    Secp256k1.derivePublicKey = derivePublicKey;
    /**
     * derive Address from public key
     * @param pubKey the public key
     */
    function deriveAddress(pubKey) {
        return new types_1.Address(keccak256(pubKey.slice(1)).bytes);
    }
    Secp256k1.deriveAddress = deriveAddress;
    /**
     * sign a message using elliptic curve algorithm on the curve secp256k1
     * @param msgHash hash of message
     * @param privKey serialized private key
     */
    function sign(msgHash, privKey) {
        let sig = secp256k1.sign(msgHash.bytes, privKey.bytes);
        let packed = Buffer.alloc(65);
        sig.signature.copy(packed);
        packed[64] = sig.recovery;
        return packed;
    }
    Secp256k1.sign = sign;
    /**
     * recovery signature to public key
     * @param msgHash hash of message
     * @param sig signature
     */
    function recover(msgHash, sig) {
        if (sig.length != 65)
            throw new Error('invalid signature');
        let recovery = sig[64];
        if (recovery !== 0 && recovery !== 1)
            throw new Error('invalid signature recovery');
        return secp256k1.recover(msgHash.bytes, sig.slice(0, 64), recovery, false);
    }
    Secp256k1.recover = recover;
})(Secp256k1 = exports.Secp256k1 || (exports.Secp256k1 = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBMEM7QUFDMUMsbUNBQW9DO0FBQ3BDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUNoQyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUE7QUFDdEMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0FBRWhDOzs7R0FHRztBQUNILG9CQUEyQixHQUFHLElBQXlCO0lBQ25ELElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDYixJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBOztZQUUzQixLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFBO0lBQ3hELENBQUMsQ0FBQyxDQUFBO0lBQ0YsT0FBTyxJQUFJLGVBQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzVELENBQUM7QUFURCxnQ0FTQztBQUVEOzs7R0FHRztBQUNILG1CQUEwQixHQUFHLElBQXlCO0lBQ2xELElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtJQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2IsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNsQixDQUFD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