"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = require("bignumber.js");
const hexRegEx = /^[0-9a-f]*$/i;
function hexToBuffer(hex, prefix = '0x') {
    if (!hex.startsWith(prefix))
        throw new Error('prefix mismatch');
    hex = hex.substr(prefix.length);
    if (!hexRegEx.test(hex))
        throw new Error('not in hex format');
    if (hex.length % 2 != 0) {
        throw new Error('odd hex');
    }
    return Buffer.from(hex, 'hex');
}
/**
 * Address class.
 */
class Address {
    /**
     * parses hex string to Address.
     * @param hex the hex string
     * @param prefix prefix to match against, defaults to '0x'
     */
    static fromHex(hex, prefix = '0x') {
        let bytes = hexToBuffer(hex, prefix);
        if (bytes.length != 20)
            throw new Error('address should be 20 bytes');
        return new Address(bytes);
    }
    /**
     * construct Address object from Buffer.
     * @param bytes
     */
    constructor(bytes) {
        let b20 = Buffer.alloc(20);
        bytes.copy(b20, b20.length > bytes.length ? b20.length - bytes.length : 0, bytes.length > b20.length ? bytes.length - b20.length : 0);
        this.bytes = b20;
    }
    /**
     * convert to string presentation, in hex form.
     * @param prefix prefix added before string, defaults to '0x'
     */
    toString(prefix = '0x') {
        return (prefix || '') + this.bytes.toString('hex');
    }
}
exports.Address = Address;
/**
 * Bytes32 class.
 */
class Bytes32 {
    /**
     * parses hex string to Bytes32.
     * @param hex the hex string
     * @param prefix prefix to match against, defaults to '0x'
     */
    static fromHex(hex, prefix = '0x') {
        let bytes = hexToBuffer(hex, prefix);
        if (bytes.length != 32)
            throw new Error('bytes32 should be 32 bytes');
        return new Bytes32(bytes);
    }
    /**
     * construct Bytes32 object from Buffer.
     * @param bytes
     */
    constructor(bytes) {
        let b32 = Buffer.alloc(32);
        bytes.copy(b32, b32.length > bytes.length ? b32.length - bytes.length : 0, bytes.length > b32.length ? bytes.length - b32.length : 0);
        this.bytes = b32;
    }
    /**
    * convert to string presentation, in hex form.
    * @param prefix prefix added before string, defaults to '0x'
    */
    toString(prefix = '0x') {
        return (prefix || '') + this.bytes.toString('hex');
    }
}
exports.Bytes32 = Bytes32;
/**
 * BigInt class presents non-negative big integer
 */
class BigInt {
    /**
     * parse a value to BigInt.
     * @param v can be a integer in types of number, string and BigNumber
     */
    static from(v) {
        let bn;
        if (typeof v === 'string') {
            bn = new bignumber_js_1.default(v);
        }
        else if (typeof v === 'number') {
            bn = new bignumber_js_1.default(v);
        }
        else {
            bn = v;
        }
        if (bn.isNegative()) {
            throw new Error('negative number');
        }
        if (!bn.isInteger()) {
            throw new Error('not a integer');
        }
        let hex = bn.toString(16);
        if (hex.length % 2 != 0)
            hex = '0' + hex;
        return new BigInt(Buffer.from(hex, 'hex'));
    }
    /**
     * construct BigInt object from Buffer.
     * @param bytes
     */
    constructor(bytes) {
        // trim leading zero
        let i = 0;
        for (; i < bytes.length; i++) {
            if (bytes[i] != 0)
                break;
        }
        this.bytes = bytes.slice(i);
    }
    /**
     * convert to BigNumber
     */
    toBigNumber() {
        return new bignumber_js_1.default(this.bytes.toString('hex'), 16);
    }
    /**
     * convert to string
     * @param base the base, 16 or 10, defaults to 16
     */
    toString(base = 16) {
        let prefix = (base === 16) ? '0x' : '';
        return prefix + this.toBigNumber().toString(base);
    }
}
exports.BigInt = BigInt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3R5cGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsK0NBQW9DO0FBRXBDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQTtBQUUvQixxQkFBcUIsR0FBVyxFQUFFLE1BQU0sR0FBRyxJQUFJO0lBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztRQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7SUFFdEMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7SUFFeEMsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQTtLQUM3QjtJQUNELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDbEMsQ0FBQztBQUVEOztHQUVHO0FBQ0g7SUFDSTs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFXLEVBQUUsTUFBTSxHQUFHLElBQUk7UUFDckMsSUFBSSxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQTtRQUNwQyxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksRUFBRTtZQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUE7UUFFakQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUM3QixDQUFDO0lBS0Q7OztPQUdHO0lBQ0gsWUFBWSxLQUFhO1FBQ3JCLElBQUksR0FB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